#!/usr/bin/python
#encoding=UTF-8

import sys, os, subprocess, time;
import xml.etree.ElementTree as ET;
from FlightGear import FlightGear;

def get_report(fg, args):
    print fg.get_report();
    return 0;

def sound_on(fg, args):
    fg['/sim/sound/enabled'] = 1;
    return 0;

def sound_off(fg, args):
    fg['/sim/sound/enabled'] = 0;
    return 0;

def pause(fg, args):
    fg['/sim/freeze/master'] = fg['/sim/freeze/clock'] = 1;

def resume(fg, args):
    fg['/sim/freeze/master'] = fg['/sim/freeze/clock'] = 0;

def pause_manager(fg, args):
    enabled = fg['/autopilot/settings/pause-manager-enabled'];
    if (1 == fg['/sim/freeze/master'] and 1 == fg['/sim/freeze/clock']):
        print('Simulation paused.');
    elif (0 != len(args)):
        try:
            distance = int(args[0]);
            if (distance <= 0):
                fg['/autopilot/settings/pause-manager-enabled'] = 0;
                print('Pause Manager deactivated.');
            else:
                fg['/autopilot/settings/pause-manager-distance'] = distance;
                fg['/autopilot/settings/pause-manager-enabled'] = 1;
                print("Pause Manager activated, \
simulation will be paused when the remaining route is \
shorter than %d nmi." % int(fg['/autopilot/settings/pause-manager-distance']));
        except ValueError:
            sys.stderr.write('Invalid number given');
            return 1;
    elif ('1' == enabled):
        print("Pause Manager enabled, \
simulation will be paused when the remaining route is \
shorter than %d nmi." % int(fg['/autopilot/settings/pause-manager-distance']));
    else:
        print('Pause Manager is inactive.');
    return 0;

def load_route(fg, args):
    try:
        fg['/autopilot/route-manager/file-path'] = os.path.abspath(args[0]);
        fg['/autopilot/route-manager/input'] = '@LOAD';
        fg['/autopilot/route-manager/departure/sid'] = 'DEFAULT';
        fg['/autopilot/route-manager/destination/approach'] = 'DEFAULT';
        fg['/autopilot/route-manager/input'] = '@ACTIVATE';
        fg['/autopilot/route-manager/input'] = '@JUMP0';
    except Exception, e:
        print 'Failed to load route: ' + str(e);
        return 1;

    return 0;

def fglaunch(args):
    fgfs_possible_exec = [
        '/usr/bin/fgfs',
        '/usr/local/bin/fgfs',
        os.getenv('FGFS_EXEC'),
    ];

    try:
        aircraft = args[0];
        flight_plan = os.path.abspath(args[1]);
    except IndexError:
        print 'Usage: launch AIRCRAFT FLIGHT_PLAN';
        exit(1);

    #Get runway to takeoff
    try:
        fp_tree = ET.parse(flight_plan);
        fp_root = fp_tree.getroot();
        airport = fp_root.findall('departure/airport')[0].text;
        runway = fp_root.findall('departure/runway')[0].text;
    except Exception, e:
        print 'Failed to parse flight plan: ' + str(e);
        return 1;

    #Launch FlightGear
    fgfs_exec = None;
    for i in fgfs_possible_exec:
        if os.path.isfile(i):
            fgfs_exec = i;
            break;
    if (fgfs_exec == None):
        print 'Executable of fgfs not found.';
        return 1;
    subprocess.Popen([fgfs_exec, '--aircraft='+aircraft, '--airport='+airport, '--runway='+runway] + args[2:]);

    #Wait for FlightGear initialized
    address, port = os.getenv('FG_TELNET').split(':');
    initialized = False;
    while not initialized:
        fg = None;
        try:
            fg = FlightGear(address, int(port));
            if (fg['/sim/signals/fdm-initialized']):
                initialized = True;
        except Exception, e:
            sys.stderr.write('Error: '+ str(e) + "\n");
            initialized = False;
        if (None != fg):
            fg.quit();
        time.sleep(0.5);

    #Load route
    fg = FlightGear(address, int(port));
    load_route(fg, [flight_plan]);
    fg.quit();

    #Finished
    return 0;

if __name__ == '__main__':
    command_all = {
        'report': get_report,
        'soundon': sound_on,
        'soundoff': sound_off,
        'pausemgr': pause_manager,
        'pause': pause,
        'resume': resume,
        'loadroute': load_route,
    };

    if (len(sys.argv) < 2):
        sys.stderr.write('Command not given.\n');
        exit(1);

    command = sys.argv[1];
    if ('launch' == command):
        exit(fglaunch(sys.argv[2:]));

    fg = None;
    retcode = 0;
    try:
        func = command_all[command];
        address, port = os.getenv('FG_TELNET').split(':');
        fg = FlightGear(address, int(port));
        retcode = func(fg, sys.argv[2:]);
        fg.quit();
    except KeyError:
        sys.stderr.write('Bad command.\n');
        exit(1);
    except Exception, e:
        sys.stderr.write(str(e) + "\n");
        if (None != fg):
            fg.quit();
        exit(1);
    exit(retcode);

