#!/usr/bin/python
#encoding=UTF-8

import sys, os, subprocess, time, platform;
import xml.etree.ElementTree as ET;
from FlightGear import FlightGear;

def get_report(fg, args):
	print fg.get_report();
	return 0;

def sound_on(fg, args):
	fg['/sim/sound/enabled'] = 1;
	return 0;

def sound_off(fg, args):
	fg['/sim/sound/enabled'] = 0;
	return 0;

def pause(fg, args):
	fg['/sim/freeze/master'] = fg['/sim/freeze/clock'] = 1;

def resume(fg, args):
	fg['/sim/freeze/master'] = fg['/sim/freeze/clock'] = 0;

def pause_manager(fg, args):
	enabled = fg['/autopilot/settings/pause-manager-enabled'];
	distance = int(fg['/autopilot/settings/pause-manager-distance']);

	# Simulation is already paused.
	if (1 == fg['/sim/freeze/master'] and 1 == fg['/sim/freeze/clock']):
		print('Simulation paused.');
	# No argument provided, show status of Pause Manager.
	elif (0 == len(args)):
		if ('1' == enabled):
			print("Pause Manager is active, simulation will be paused when the remaining route is shorter than %d nmi." % distance);
		else:
			print('Pause Manager is inactive.');
	# Argument given
	else:
		# Read distance value from args
		try:
			distance = int(args[0]);
		except ValueError:
			sys.stderr.write('Invalid number given');
			return 1;

		# Deactivate Pause Manager when a negative value was given.
		if (distance <= 0):
			fg['/autopilot/settings/pause-manager-enabled'] = 0;
			print('Pause Manager deactivated.');
		else:
			fg['/autopilot/settings/pause-manager-distance'] = distance;
			fg['/autopilot/settings/pause-manager-enabled'] = 1;
			print("Pause Manager activated, simulation will be paused when the remaining route is shorter than %d nmi." % distance);

	return 0;

def fglaunch(args):
	#Check if reboot is required
	if ('Linux' == platform.system() and os.path.isfile('/var/run/reboot-required')):
		print 'Please reboot your machine before launching FlightGear.';
		return 1;

	fgfs_possible_exec = [
		'/usr/bin/fgfs',
		'/usr/local/bin/fgfs',
		os.getenv('FGFS_EXEC'),
	];

	try:
		aircraft = args[0];
	except IndexError:
		print 'Usage: launch AIRCRAFT FLIGHT_PLAN Other_fgfs_Arguments ...';
		return 1;

	#Get runway to takeoff
	fp_params = None;
	try:
		flight_plan = os.path.abspath(args[1]);
		fp_tree = ET.parse(flight_plan);
		fp_root = fp_tree.getroot();
		airport = fp_root.findall('departure/airport')[0].text;
		runway = fp_root.findall('departure/runway')[0].text;
		fp_params = ['--airport='+airport, '--runway='+runway, '--flight-plan='+flight_plan];
	except Exception, e:
		print 'Failed to parse flight plan: ' + str(e);
		fp_params = [];

	#Launch FlightGear
	fgfs_exec = None;
	for i in fgfs_possible_exec:
		if os.path.isfile(i):
			fgfs_exec = i;
			break;
	if (fgfs_exec == None):
		print 'Executable of fgfs not found.';
		return 1;

	return subprocess.call([fgfs_exec, '--aircraft='+aircraft] + fp_params + args[2:]);

if __name__ == '__main__':
	command_all = {
		'report': get_report,
		'soundon': sound_on,
		'soundoff': sound_off,
		'pausemgr': pause_manager,
		'pause': pause,
		'resume': resume,
	};

	if (len(sys.argv) < 2):
		sys.stderr.write('Command not given.\n');
		exit(1);

	command = sys.argv[1];
	if ('launch' == command):
		exit(fglaunch(sys.argv[2:]));

	fg = None;
	retcode = 0;
	try:
		func = command_all[command];
		address, port = os.getenv('FG_TELNET').split(':');
		fg = FlightGear(address, int(port));
		retcode = func(fg, sys.argv[2:]);
		fg.quit();
	except KeyError:
		sys.stderr.write('Bad command.\n');
		exit(1);
	except Exception, e:
		sys.stderr.write(str(e) + "\n");
		if (None != fg):
			fg.quit();
		exit(1);
	exit(retcode);

